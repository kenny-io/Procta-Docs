---
title: "Wallet Infrastructure Integration"
description: "End-to-end tutorial: Build agent verification into your wallet-as-a-service, MPC key management, or smart account platform with pre-sign checks and credential-based trust."
---

This tutorial walks through integrating Procta into wallet infrastructure — wallet-as-a-service platforms, MPC key management systems, and smart account providers. By the end, every agent signing request will be identity-verified and scope-checked before your wallet co-signs or releases a key share.

## What you'll build

A verification layer that gates every agent signing request. Before your wallet infrastructure co-signs a transaction or releases an MPC key share, Procta confirms the agent is authorized for that specific action, amount, and asset.

**Architecture overview:**

```
Agent requests signature → Wallet API → Procta /verify → ALLOWED → Co-sign / Release key share
                                                        → DENIED  → Reject + Log
```

## Prerequisites

- A Procta relying party account and API key ([register here](/quickstart))
- Node.js 18+ or Python 3.10+
- An existing wallet-as-a-service or MPC signing infrastructure

## Register your wallet platform

```bash
curl -X POST https://api.procta.org/v1/relying-parties \
  -H "Content-Type: application/json" \
  -d '{
    "name": "SecureWalletCo",
    "contactEmail": "security@securewallet.xyz",
    "password": "your-secure-password"
  }'
```

```bash
export PROCTA_RP_KEY="prc_rp_xyz789..."
```

## Build the signing gate

Create a verification layer that intercepts every signing request from an agent.

<CodeGroup title="Signing gate middleware">

```ts
// src/signing/procta-gate.ts

interface SigningRequest {
  kyaId: string
  action: string
  amount: string
  asset: string
  destinationAddress?: string
  chainId: number
}

interface SigningGateResult {
  approved: boolean
  reason?: string
  verificationId?: string
}

export async function verifySigningRequest(
  req: SigningRequest
): Promise<SigningGateResult> {
  try {
    const response = await fetch('https://api.procta.org/v1/verify', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_RP_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        kya_id: req.kyaId,
        action: req.action,
        amount: req.amount,
        asset: req.asset,
      }),
    })

    const result = await response.json()

    return {
      approved: result.decision === 'ALLOWED',
      reason: result.reason,
      verificationId: result.verificationId,
    }
  } catch (err) {
    // Fail closed — never sign without verification
    return { approved: false, reason: `Verification unavailable: ${err}` }
  }
}
```

```python
# signing/procta_gate.py
import os
import requests

PROCTA_API_URL = "https://api.procta.org/v1/verify"
PROCTA_RP_KEY = os.environ["PROCTA_RP_KEY"]


def verify_signing_request(
    kya_id: str, action: str, amount: str, asset: str
) -> dict:
    try:
        resp = requests.post(
            PROCTA_API_URL,
            headers={"Authorization": f"Bearer {PROCTA_RP_KEY}"},
            json={
                "kya_id": kya_id,
                "action": action,
                "amount": amount,
                "asset": asset,
            },
            timeout=5,
        )
        result = resp.json()
        return {
            "approved": result["decision"] == "ALLOWED",
            "reason": result.get("reason"),
            "verification_id": result.get("verificationId"),
        }
    except requests.RequestException as e:
        return {"approved": False, "reason": f"Verification unavailable: {e}"}
```

</CodeGroup>

## Integrate into your signing service

Wire the verification gate into your wallet's signing endpoints.

<CodeGroup title="Wallet signing service">

```ts
// src/routes/signing.ts
import express from 'express'
import { verifySigningRequest } from '../signing/procta-gate'
import { mpcSign } from '../mpc/signer'

const router = express.Router()

router.post('/sign', async (req, res) => {
  const { kya_id, action, amount, asset, chain_id, tx_payload } = req.body

  if (!kya_id) {
    return res.status(400).json({ error: 'Missing kya_id — agent identity required' })
  }

  // 1. Verify the agent's authorization
  const gate = await verifySigningRequest({
    kyaId: kya_id,
    action,
    amount,
    asset,
    chainId: chain_id,
  })

  if (!gate.approved) {
    console.warn(`Signing denied for ${kya_id}: ${gate.reason}`)
    return res.status(403).json({
      error: 'SIGNING_DENIED',
      reason: gate.reason,
    })
  }

  // 2. Agent is verified — proceed with MPC co-signing
  try {
    const signature = await mpcSign({
      payload: tx_payload,
      keyId: req.body.wallet_id,
      metadata: {
        agentKyaId: kya_id,
        verificationId: gate.verificationId,
        action,
        amount,
        asset,
      },
    })

    return res.json({
      signature,
      verificationId: gate.verificationId,
    })
  } catch (err) {
    return res.status(500).json({ error: 'Signing failed', details: String(err) })
  }
})

// Batch signing — verify each transaction individually
router.post('/sign/batch', async (req, res) => {
  const { kya_id, transactions } = req.body
  const results = []

  for (const tx of transactions) {
    const gate = await verifySigningRequest({
      kyaId: kya_id,
      action: tx.action,
      amount: tx.amount,
      asset: tx.asset,
      chainId: tx.chain_id,
    })

    if (!gate.approved) {
      results.push({
        index: tx.index,
        signed: false,
        reason: gate.reason,
      })
      continue
    }

    const signature = await mpcSign({
      payload: tx.tx_payload,
      keyId: tx.wallet_id,
      metadata: {
        agentKyaId: kya_id,
        verificationId: gate.verificationId,
      },
    })

    results.push({
      index: tx.index,
      signed: true,
      signature,
      verificationId: gate.verificationId,
    })
  }

  return res.json({ results })
})

export default router
```

```python
# routes/signing.py
from flask import Blueprint, request, jsonify
from signing.procta_gate import verify_signing_request
from mpc.signer import mpc_sign

signing = Blueprint("signing", __name__)


@signing.route("/sign", methods=["POST"])
def sign_transaction():
    data = request.get_json()
    kya_id = data.get("kya_id")

    if not kya_id:
        return jsonify({"error": "Missing kya_id"}), 400

    # 1. Verify the agent
    gate = verify_signing_request(
        kya_id=kya_id,
        action=data["action"],
        amount=data["amount"],
        asset=data["asset"],
    )

    if not gate["approved"]:
        return jsonify({
            "error": "SIGNING_DENIED",
            "reason": gate["reason"],
        }), 403

    # 2. Proceed with MPC co-signing
    signature = mpc_sign(
        payload=data["tx_payload"],
        key_id=data["wallet_id"],
        metadata={
            "agent_kya_id": kya_id,
            "verification_id": gate["verification_id"],
        },
    )

    return jsonify({
        "signature": signature,
        "verification_id": gate["verification_id"],
    })


@signing.route("/sign/batch", methods=["POST"])
def sign_batch():
    data = request.get_json()
    kya_id = data["kya_id"]
    results = []

    for tx in data["transactions"]:
        gate = verify_signing_request(
            kya_id=kya_id,
            action=tx["action"],
            amount=tx["amount"],
            asset=tx["asset"],
        )

        if not gate["approved"]:
            results.append({"index": tx["index"], "signed": False, "reason": gate["reason"]})
            continue

        signature = mpc_sign(
            payload=tx["tx_payload"],
            key_id=tx["wallet_id"],
            metadata={"agent_kya_id": kya_id, "verification_id": gate["verification_id"]},
        )

        results.append({
            "index": tx["index"],
            "signed": True,
            "signature": signature,
            "verification_id": gate["verification_id"],
        })

    return jsonify({"results": results})
```

</CodeGroup>

<Note type="warning" title="Batch signing">
When processing batch signing requests, verify each transaction individually. An agent may be authorized for some actions but not others within the same batch.
</Note>

## Add offline credential verification

For latency-sensitive signing flows, validate the agent's Procta-issued Verifiable Credential locally instead of making a network call to `/verify`.

<CodeGroup title="Offline credential verification">

```ts
// src/signing/credential-verify.ts
import { verifyCredential, VerifiableCredential } from '@procta/sdk'

interface CredentialVerifyResult {
  valid: boolean
  agent?: {
    kyaId: string
    scopes: string[]
    owner: string
  }
  reason?: string
}

export async function verifyAgentCredential(
  vcJwt: string
): Promise<CredentialVerifyResult> {
  try {
    const result = await verifyCredential(vcJwt)

    if (!result.verified) {
      return { valid: false, reason: 'Credential signature invalid' }
    }

    const credential = result.credential as VerifiableCredential
    const subject = credential.credentialSubject

    // Check expiration
    if (credential.expirationDate && new Date(credential.expirationDate) < new Date()) {
      return { valid: false, reason: 'Credential expired' }
    }

    return {
      valid: true,
      agent: {
        kyaId: subject.kyaId,
        scopes: subject.scopes,
        owner: subject.ownerId,
      },
    }
  } catch (err) {
    return { valid: false, reason: `Credential verification failed: ${err}` }
  }
}

// Use in signing flow for low-latency paths
router.post('/sign/fast', async (req, res) => {
  const { vc_jwt, action, tx_payload, wallet_id } = req.body

  // Offline verification — no network call to Procta
  const credential = await verifyAgentCredential(vc_jwt)

  if (!credential.valid) {
    return res.status(403).json({
      error: 'CREDENTIAL_INVALID',
      reason: credential.reason,
    })
  }

  // Check scope locally
  if (!credential.agent!.scopes.includes(action)) {
    return res.status(403).json({
      error: 'SCOPE_NOT_AUTHORIZED',
      reason: `Agent lacks scope: ${action}`,
    })
  }

  // Credential valid and scope matches — sign
  const signature = await mpcSign({ payload: tx_payload, keyId: wallet_id })
  return res.json({ signature })
})
```

```python
# signing/credential_verify.py
from procta_sdk import verify_credential
from datetime import datetime, timezone


def verify_agent_credential(vc_jwt: str) -> dict:
    try:
        result = verify_credential(vc_jwt)

        if not result["verified"]:
            return {"valid": False, "reason": "Credential signature invalid"}

        credential = result["credential"]
        subject = credential["credentialSubject"]

        # Check expiration
        if credential.get("expirationDate"):
            exp = datetime.fromisoformat(credential["expirationDate"])
            if exp < datetime.now(timezone.utc):
                return {"valid": False, "reason": "Credential expired"}

        return {
            "valid": True,
            "agent": {
                "kya_id": subject["kyaId"],
                "scopes": subject["scopes"],
                "owner": subject["ownerId"],
            },
        }
    except Exception as e:
        return {"valid": False, "reason": f"Credential verification failed: {e}"}
```

</CodeGroup>

<Note type="info" title="When to use offline vs. online verification">
Use **online** (`/verify`) for full authorization checks including real-time limits and agent status. Use **offline** (credential verification) when latency is critical and you only need identity + scope confirmation.
</Note>

## Verify owner-wallet linkage

Confirm that the agent belongs to the same verified owner as the wallet, preventing cross-account agent access.

<CodeGroup title="Owner-wallet linkage check">

```ts
// src/signing/owner-check.ts

export async function verifyOwnerWalletLink(
  kyaId: string,
  walletOwnerId: string
): Promise<boolean> {
  const response = await fetch(
    `https://api.procta.org/v1/agents/lookup`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_RP_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ kya_id: kyaId }),
    }
  )

  const result = await response.json()

  // Confirm the agent's owner matches the wallet's owner
  return result.owner?.id === walletOwnerId
}

// Use in signing flow
const ownerMatch = await verifyOwnerWalletLink(kya_id, wallet.ownerId)
if (!ownerMatch) {
  return res.status(403).json({
    error: 'OWNER_MISMATCH',
    reason: 'Agent owner does not match wallet owner',
  })
}
```

```python
# signing/owner_check.py

def verify_owner_wallet_link(kya_id: str, wallet_owner_id: str) -> bool:
    resp = requests.post(
        "https://api.procta.org/v1/agents/lookup",
        headers={"Authorization": f"Bearer {PROCTA_RP_KEY}"},
        json={"kya_id": kya_id},
        timeout=5,
    )
    result = resp.json()
    return result.get("owner", {}).get("id") == wallet_owner_id
```

</CodeGroup>

## Test the integration

```bash
# Test a verified signing request
curl -X POST http://localhost:3000/sign \
  -H "Content-Type: application/json" \
  -d '{
    "kya_id": "kya_01kwallet9x3mfq72a0",
    "action": "transfer:crypto",
    "amount": "1000.00",
    "asset": "USDC",
    "chain_id": 1,
    "wallet_id": "wallet_abc123",
    "tx_payload": "0x..."
  }'
```

**Expected behavior:**

| Scenario | Result | HTTP Status |
|---|---|---|
| Agent authorized, owner matches wallet | Signature returned | `200` |
| Agent lacks required scope | `SIGNING_DENIED` | `403` |
| Agent's owner ≠ wallet owner | `OWNER_MISMATCH` | `403` |
| Amount exceeds agent limits | `SIGNING_DENIED` | `403` |
| Procta unreachable | `VERIFICATION_UNAVAILABLE` | `503` |

## What's next

- **[Wallet Infrastructure use case](/use-cases/wallet-infrastructure)** — Conceptual overview of wallet-level verification
- **[Credentials](/credentials)** — How Procta's W3C Verifiable Credentials work
- **[Verification deep dive](/verification)** — Decision logic, response format, and edge cases
- **[Key Rotation](/guides/key-rotation)** — Rotate agent credentials without downtime
