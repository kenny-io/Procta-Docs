---
title: "Trading Bot Platform Integration"
description: "End-to-end tutorial: Build agent verification into your trading bot platform with pre-trade checks, scope enforcement, and real-time limit validation."
---

This tutorial walks through integrating Procta's agent verification into a trading bot platform from scratch. By the end, every bot-initiated trade on your platform will be identity-verified, scope-checked, and limit-enforced before execution.

## What you'll build

A verification layer that sits between your trading engine and incoming bot requests. Every order — spot, futures, or margin — is checked against the bot's Procta identity before it reaches your matching engine.

**Architecture overview:**

```
Bot Request → API Gateway → Procta Verification → Trading Engine → Exchange
                                  ↓
                          DENIED → Reject + Log
```

## Prerequisites

- A Procta relying party account and API key ([register here](/quickstart))
- Node.js 18+ or Python 3.10+
- Your existing trading platform API

## Register as a relying party

<CodeGroup title="Register your platform">

```bash
curl -X POST https://api.procta.org/v1/relying-parties \
  -H "Content-Type: application/json" \
  -d '{
    "name": "AcmeTrading",
    "contactEmail": "integrations@acmetrading.com",
    "password": "your-secure-password"
  }'
```

</CodeGroup>

Save the returned `apiKey` as an environment variable:

```bash
export PROCTA_RP_KEY="prc_rp_xyz789..."
```

<Note type="danger" title="Save your API key">
The API key is shown **only once**. Store it immediately as an environment variable or in your secrets manager.
</Note>

## Create the verification middleware

Build a middleware function that intercepts every incoming trade request and verifies the bot's identity and authorization before forwarding to your trading engine.

<CodeGroup title="Verification middleware">

```ts
// src/middleware/procta-verify.ts
import type { Request, Response, NextFunction } from 'express'

interface VerifyResponse {
  decision: 'ALLOWED' | 'DENIED'
  reason?: string
  agent?: {
    kyaId: string
    name: string
    scope: string[]
    limits: { perTransaction: string; daily: string }
  }
}

export async function verifyTradeAction(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const { kya_id, action, amount, asset } = req.body

  if (!kya_id) {
    return res.status(400).json({ error: 'Missing kya_id in request body' })
  }

  try {
    const response = await fetch('https://api.procta.org/v1/verify', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_RP_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ kya_id, action, amount, asset }),
    })

    const result: VerifyResponse = await response.json()

    if (result.decision === 'ALLOWED') {
      // Attach verified agent info to the request for downstream use
      req.verifiedAgent = result.agent
      return next()
    }

    // Denied — log and reject
    console.warn(`Trade denied for ${kya_id}: ${result.reason}`)
    return res.status(403).json({
      error: 'VERIFICATION_FAILED',
      reason: result.reason,
    })
  } catch (err) {
    console.error('Procta verification error:', err)
    // Fail closed — deny on error
    return res.status(503).json({
      error: 'VERIFICATION_UNAVAILABLE',
      reason: 'Could not reach verification service',
    })
  }
}
```

```python
# middleware/procta_verify.py
import os
import requests
from functools import wraps
from flask import request, jsonify, g

PROCTA_API_URL = "https://api.procta.org/v1/verify"
PROCTA_RP_KEY = os.environ["PROCTA_RP_KEY"]


def verify_trade_action(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        data = request.get_json()
        kya_id = data.get("kya_id")

        if not kya_id:
            return jsonify({"error": "Missing kya_id in request body"}), 400

        try:
            resp = requests.post(
                PROCTA_API_URL,
                headers={"Authorization": f"Bearer {PROCTA_RP_KEY}"},
                json={
                    "kya_id": kya_id,
                    "action": data.get("action"),
                    "amount": data.get("amount"),
                    "asset": data.get("asset"),
                },
                timeout=5,
            )
            result = resp.json()

            if result["decision"] == "ALLOWED":
                g.verified_agent = result.get("agent")
                return f(*args, **kwargs)

            return jsonify({
                "error": "VERIFICATION_FAILED",
                "reason": result.get("reason"),
            }), 403

        except requests.RequestException as e:
            # Fail closed
            return jsonify({
                "error": "VERIFICATION_UNAVAILABLE",
                "reason": str(e),
            }), 503

    return decorated
```

</CodeGroup>

<Note type="info" title="Fail closed">
Always deny trade execution if the verification service is unreachable. This prevents unauthorized trades during outages.
</Note>

## Wire into your trade routes

Apply the middleware to every trade endpoint on your platform.

<CodeGroup title="Apply to trade routes">

```ts
// src/routes/trades.ts
import express from 'express'
import { verifyTradeAction } from '../middleware/procta-verify'

const router = express.Router()

// All trade endpoints require Procta verification
router.post('/orders/spot', verifyTradeAction, async (req, res) => {
  const { verifiedAgent } = req
  console.log(`Executing spot order for agent: ${verifiedAgent.name}`)

  // Your existing order execution logic
  const order = await executeSpotOrder({
    pair: req.body.pair,
    side: req.body.side,
    amount: req.body.amount,
    agentId: verifiedAgent.kyaId,
  })

  res.json({ order })
})

router.post('/orders/futures', verifyTradeAction, async (req, res) => {
  const { verifiedAgent } = req
  console.log(`Executing futures order for agent: ${verifiedAgent.name}`)

  const order = await executeFuturesOrder({
    pair: req.body.pair,
    side: req.body.side,
    amount: req.body.amount,
    leverage: req.body.leverage,
    agentId: verifiedAgent.kyaId,
  })

  res.json({ order })
})

export default router
```

```python
# routes/trades.py
from flask import Blueprint, request, jsonify, g
from middleware.procta_verify import verify_trade_action

trades = Blueprint("trades", __name__)


@trades.route("/orders/spot", methods=["POST"])
@verify_trade_action
def create_spot_order():
    agent = g.verified_agent
    data = request.get_json()

    order = execute_spot_order(
        pair=data["pair"],
        side=data["side"],
        amount=data["amount"],
        agent_id=agent["kyaId"],
    )

    return jsonify({"order": order})


@trades.route("/orders/futures", methods=["POST"])
@verify_trade_action
def create_futures_order():
    agent = g.verified_agent
    data = request.get_json()

    order = execute_futures_order(
        pair=data["pair"],
        side=data["side"],
        amount=data["amount"],
        leverage=data["leverage"],
        agent_id=agent["kyaId"],
    )

    return jsonify({"order": order})
```

</CodeGroup>

## Test the integration

Send a test trade request with a valid bot identity:

<CodeGroup title="Test a verified trade">

```bash
curl -X POST http://localhost:3000/orders/spot \
  -H "Content-Type: application/json" \
  -d '{
    "kya_id": "kya_01kbot9x3mfq72a0trading",
    "action": "trading:spot",
    "amount": "5000.00",
    "asset": "USDC",
    "pair": "BTC/USDC",
    "side": "buy"
  }'
```

</CodeGroup>

**Expected responses:**

| Scenario | Decision | HTTP Status |
|---|---|---|
| Bot authorized for `trading:spot`, within limits | `ALLOWED` | `200` |
| Bot lacks `trading:spot` scope | `DENIED` | `403` |
| Amount exceeds per-transaction limit | `DENIED` | `403` |
| Bot is suspended or revoked | `DENIED` | `403` |
| Procta API unreachable | N/A | `503` |

## Add webhook listeners for real-time updates

Subscribe to Procta webhooks so your platform reacts immediately when a bot's status changes — revocation, scope changes, or limit updates.

<CodeGroup title="Webhook handler">

```ts
// src/routes/webhooks.ts
import express from 'express'

const router = express.Router()

router.post('/procta/webhooks', async (req, res) => {
  const event = req.body

  switch (event.type) {
    case 'agent.revoked':
      // Immediately cancel all open orders for this agent
      await cancelOpenOrders(event.data.kyaId)
      console.log(`Agent ${event.data.kyaId} revoked — orders cancelled`)
      break

    case 'agent.scope_updated':
      // Log scope change for audit
      console.log(`Agent ${event.data.kyaId} scopes updated to: ${event.data.scopes}`)
      break

    case 'agent.limits_updated':
      // Update cached limits
      await updateCachedLimits(event.data.kyaId, event.data.limits)
      break
  }

  res.status(200).json({ received: true })
})

export default router
```

```python
# routes/webhooks.py
from flask import Blueprint, request, jsonify

webhooks = Blueprint("webhooks", __name__)


@webhooks.route("/procta/webhooks", methods=["POST"])
def handle_procta_webhook():
    event = request.get_json()

    if event["type"] == "agent.revoked":
        cancel_open_orders(event["data"]["kyaId"])

    elif event["type"] == "agent.scope_updated":
        print(f"Agent {event['data']['kyaId']} scopes: {event['data']['scopes']}")

    elif event["type"] == "agent.limits_updated":
        update_cached_limits(event["data"]["kyaId"], event["data"]["limits"])

    return jsonify({"received": True}), 200
```

</CodeGroup>

## Monitor with audit trails

Pull verification logs for compliance reporting and anomaly detection:

```bash
curl https://api.procta.org/v1/audit/logs \
  -H "Authorization: Bearer ${PROCTA_RP_KEY}" \
  -G -d "agentId=kya_01kbot9x3mfq72a0trading" \
     -d "from=2025-01-01T00:00:00Z" \
     -d "to=2025-01-31T23:59:59Z" \
     -d "format=csv"
```

## What's next

- **[Verification deep dive](/verification)** — Decision logic, response format, and edge cases
- **[Webhook setup](/webhooks)** — Configure webhook endpoints and event types
- **[Audit Trails](/guides/audit-trails)** — Query and export verification history
- **[Trading Bot Platforms use case](/use-cases/trading-bot-platforms)** — Conceptual overview of the trading bot verification pattern
