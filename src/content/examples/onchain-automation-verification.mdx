---
title: "Onchain Automation Tools Integration"
description: "End-to-end tutorial: Build agent verification into your keeper networks, liquidation bots, yield optimizers, and bridge relayers with action-level scoping and transaction limits."
---

This tutorial walks through integrating Procta into onchain automation tools — keeper networks, liquidation bots, yield optimizers, and bridge relayers. By the end, every onchain transaction your automation submits will be verified against the agent's identity, scopes, and limits.

## What you'll build

A verification gate that sits between your automation logic and onchain transaction submission. Before any transaction hits the mempool, Procta confirms the agent is authorized for that specific action and amount.

**Architecture overview:**

```
Strategy Engine → Action Decision → Procta /verify → ALLOWED → Sign & Submit Tx
                                                   → DENIED  → Skip + Alert
```

## Prerequisites

- A Procta relying party account and API key ([register here](/quickstart))
- Node.js 18+ or Python 3.10+
- An existing onchain automation system (keeper, bot, or relayer)

## Register your automation platform

```bash
curl -X POST https://api.procta.org/v1/relying-parties \
  -H "Content-Type: application/json" \
  -d '{
    "name": "KeeperNetwork",
    "contactEmail": "ops@keepernetwork.xyz",
    "password": "your-secure-password"
  }'
```

```bash
export PROCTA_RP_KEY="prc_rp_xyz789..."
```

## Define scopes for onchain actions

Map your automation's capabilities to Procta scopes. This creates a clear boundary for what each agent can do.

| Automation Type | Recommended Scopes | Example Limits |
|---|---|---|
| Keeper / Liquidator | `defi:liquidate`, `defi:read` | $50,000 per tx, $500,000 daily |
| Yield Optimizer | `defi:deposit`, `defi:withdraw`, `defi:swap` | $100,000 per tx, $1M daily |
| Bridge Relayer | `bridge:transfer`, `bridge:read` | $25,000 per tx, $250,000 daily |
| Rebalancer | `defi:swap`, `defi:read` | $10,000 per tx, $100,000 daily |

## Build the verification gate

Create a verification function that wraps every onchain transaction submission.

<CodeGroup title="Onchain verification gate">

```ts
// src/verification/onchain-gate.ts
import { ethers } from 'ethers'

interface OnchainAction {
  kyaId: string
  action: string
  amount: string
  asset: string
  targetContract: string
  chainId: number
}

interface GateResult {
  proceed: boolean
  reason?: string
  verificationId?: string
}

export async function verifyOnchainAction(
  action: OnchainAction
): Promise<GateResult> {
  try {
    const response = await fetch('https://api.procta.org/v1/verify', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_RP_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        kya_id: action.kyaId,
        action: action.action,
        amount: action.amount,
        asset: action.asset,
      }),
    })

    const result = await response.json()

    return {
      proceed: result.decision === 'ALLOWED',
      reason: result.reason,
      verificationId: result.verificationId,
    }
  } catch (err) {
    // Fail closed — never submit unverified transactions
    console.error('Verification failed, blocking transaction:', err)
    return { proceed: false, reason: `Verification error: ${err}` }
  }
}

// Verified transaction submitter
export async function submitVerifiedTransaction(
  signer: ethers.Signer,
  action: OnchainAction,
  txData: ethers.TransactionRequest
) {
  // 1. Verify before signing
  const gate = await verifyOnchainAction(action)

  if (!gate.proceed) {
    console.warn(
      `Blocked: ${action.action} for ${action.amount} ${action.asset} — ${gate.reason}`
    )
    return { submitted: false, reason: gate.reason }
  }

  // 2. Sign and submit
  const tx = await signer.sendTransaction(txData)
  const receipt = await tx.wait()

  console.log(
    `Verified tx submitted: ${receipt.hash} (verification: ${gate.verificationId})`
  )

  return {
    submitted: true,
    txHash: receipt.hash,
    verificationId: gate.verificationId,
  }
}
```

```python
# verification/onchain_gate.py
import os
import requests
from web3 import Web3

PROCTA_API_URL = "https://api.procta.org/v1/verify"
PROCTA_RP_KEY = os.environ["PROCTA_RP_KEY"]


def verify_onchain_action(kya_id: str, action: str, amount: str, asset: str) -> dict:
    try:
        resp = requests.post(
            PROCTA_API_URL,
            headers={"Authorization": f"Bearer {PROCTA_RP_KEY}"},
            json={
                "kya_id": kya_id,
                "action": action,
                "amount": amount,
                "asset": asset,
            },
            timeout=5,
        )
        result = resp.json()
        return {
            "proceed": result["decision"] == "ALLOWED",
            "reason": result.get("reason"),
            "verification_id": result.get("verificationId"),
        }
    except requests.RequestException as e:
        return {"proceed": False, "reason": f"Verification error: {e}"}


def submit_verified_transaction(
    w3: Web3,
    account,
    kya_id: str,
    action: str,
    amount: str,
    asset: str,
    tx_data: dict,
) -> dict:
    # 1. Verify before signing
    gate = verify_onchain_action(kya_id, action, amount, asset)

    if not gate["proceed"]:
        print(f"Blocked: {action} for {amount} {asset} — {gate['reason']}")
        return {"submitted": False, "reason": gate["reason"]}

    # 2. Sign and submit
    signed_tx = account.sign_transaction(tx_data)
    tx_hash = w3.eth.send_raw_transaction(signed_tx.raw_transaction)
    receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

    print(f"Verified tx: {receipt.transactionHash.hex()} "
          f"(verification: {gate['verification_id']})")

    return {
        "submitted": True,
        "tx_hash": receipt.transactionHash.hex(),
        "verification_id": gate["verification_id"],
    }
```

</CodeGroup>

<Note type="danger" title="Fail closed">
Never submit an onchain transaction if verification fails or is unavailable. Unverified transactions can drain funds and create compliance exposure.
</Note>

## Integrate into your automation loop

Wire the verification gate into your bot's main execution loop.

<CodeGroup title="Keeper bot with verification">

```ts
// src/bots/keeper.ts
import { ethers } from 'ethers'
import { submitVerifiedTransaction } from '../verification/onchain-gate'

const AGENT_KYA_ID = process.env.AGENT_KYA_ID!

export async function keeperLoop(
  signer: ethers.Signer,
  protocolContract: ethers.Contract
) {
  while (true) {
    // 1. Check for liquidation opportunities
    const opportunities = await protocolContract.getLiquidatablePositions()

    for (const position of opportunities) {
      const amount = ethers.formatUnits(position.debt, 6) // USDC decimals

      // 2. Build the transaction
      const txData = await protocolContract.liquidate.populateTransaction(
        position.id
      )

      // 3. Verify and submit (verification happens inside)
      const result = await submitVerifiedTransaction(
        signer,
        {
          kyaId: AGENT_KYA_ID,
          action: 'defi:liquidate',
          amount,
          asset: 'USDC',
          targetContract: protocolContract.target as string,
          chainId: 1,
        },
        txData
      )

      if (result.submitted) {
        console.log(`Liquidated position ${position.id}: ${result.txHash}`)
      } else {
        console.warn(`Skipped position ${position.id}: ${result.reason}`)
      }
    }

    // Wait before next check
    await new Promise((r) => setTimeout(r, 12_000)) // ~1 block
  }
}
```

```python
# bots/keeper.py
import os
import time
from web3 import Web3
from verification.onchain_gate import submit_verified_transaction

AGENT_KYA_ID = os.environ["AGENT_KYA_ID"]


def keeper_loop(w3: Web3, account, protocol_contract):
    while True:
        # 1. Check for liquidation opportunities
        opportunities = protocol_contract.functions.getLiquidatablePositions().call()

        for position in opportunities:
            amount = str(position["debt"] / 10**6)  # USDC decimals

            # 2. Build the transaction
            tx_data = protocol_contract.functions.liquidate(
                position["id"]
            ).build_transaction({
                "from": account.address,
                "nonce": w3.eth.get_transaction_count(account.address),
            })

            # 3. Verify and submit
            result = submit_verified_transaction(
                w3,
                account,
                kya_id=AGENT_KYA_ID,
                action="defi:liquidate",
                amount=amount,
                asset="USDC",
                tx_data=tx_data,
            )

            if result["submitted"]:
                print(f"Liquidated {position['id']}: {result['tx_hash']}")
            else:
                print(f"Skipped {position['id']}: {result['reason']}")

        time.sleep(12)  # ~1 block
```

</CodeGroup>

## Yield optimizer example

<CodeGroup title="Yield optimizer with verification">

```ts
// src/bots/yield-optimizer.ts
import { submitVerifiedTransaction } from '../verification/onchain-gate'

const AGENT_KYA_ID = process.env.AGENT_KYA_ID!

export async function rebalance(
  signer: ethers.Signer,
  vaultContract: ethers.Contract,
  targetPool: string,
  amount: string
) {
  // Step 1: Withdraw from current position
  const withdrawTx = await vaultContract.withdraw.populateTransaction(amount)
  const withdrawResult = await submitVerifiedTransaction(
    signer,
    {
      kyaId: AGENT_KYA_ID,
      action: 'defi:withdraw',
      amount,
      asset: 'USDC',
      targetContract: vaultContract.target as string,
      chainId: 1,
    },
    withdrawTx
  )

  if (!withdrawResult.submitted) {
    console.warn(`Withdraw blocked: ${withdrawResult.reason}`)
    return
  }

  // Step 2: Deposit into higher-yield pool
  const depositTx = await vaultContract.deposit.populateTransaction(
    targetPool,
    amount
  )
  const depositResult = await submitVerifiedTransaction(
    signer,
    {
      kyaId: AGENT_KYA_ID,
      action: 'defi:deposit',
      amount,
      asset: 'USDC',
      targetContract: vaultContract.target as string,
      chainId: 1,
    },
    depositTx
  )

  if (depositResult.submitted) {
    console.log(`Rebalanced ${amount} USDC to ${targetPool}`)
  }
}
```

```python
# bots/yield_optimizer.py

def rebalance(w3, account, vault_contract, target_pool: str, amount: str):
    # Step 1: Withdraw from current position
    withdraw_tx = vault_contract.functions.withdraw(
        int(float(amount) * 10**6)
    ).build_transaction({
        "from": account.address,
        "nonce": w3.eth.get_transaction_count(account.address),
    })

    withdraw_result = submit_verified_transaction(
        w3, account,
        kya_id=AGENT_KYA_ID,
        action="defi:withdraw",
        amount=amount,
        asset="USDC",
        tx_data=withdraw_tx,
    )

    if not withdraw_result["submitted"]:
        print(f"Withdraw blocked: {withdraw_result['reason']}")
        return

    # Step 2: Deposit into higher-yield pool
    deposit_tx = vault_contract.functions.deposit(
        target_pool, int(float(amount) * 10**6)
    ).build_transaction({
        "from": account.address,
        "nonce": w3.eth.get_transaction_count(account.address),
    })

    deposit_result = submit_verified_transaction(
        w3, account,
        kya_id=AGENT_KYA_ID,
        action="defi:deposit",
        amount=amount,
        asset="USDC",
        tx_data=deposit_tx,
    )

    if deposit_result["submitted"]:
        print(f"Rebalanced {amount} USDC to {target_pool}")
```

</CodeGroup>

## Monitor and audit

Track all verified onchain actions for compliance and debugging:

```bash
# Pull verification logs for a specific agent
curl https://api.procta.org/v1/audit/logs \
  -H "Authorization: Bearer ${PROCTA_RP_KEY}" \
  -G -d "agentId=kya_01kkeeper9x3mfq72a0" \
     -d "action=defi:liquidate" \
     -d "from=2025-01-01T00:00:00Z" \
     -d "format=csv"
```

**Correlating verification IDs with transaction hashes** allows you to build a full audit trail from Procta decision → onchain execution.

## What's next

- **[Onchain Automation use case](/use-cases/onchain-automation)** — Conceptual overview of onchain automation verification
- **[Verification deep dive](/verification)** — Decision logic, response format, and edge cases
- **[Audit Trails](/guides/audit-trails)** — Query and export verification history
- **[Webhook setup](/webhooks)** — React to agent revocations and scope changes in real time
