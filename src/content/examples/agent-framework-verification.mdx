---
title: "Agent Framework Integration"
description: "End-to-end tutorial: Build agent verification into your agent orchestration framework with pre-execution hooks, credential issuance at deploy time, and multi-agent identity management."
---

This tutorial walks through integrating Procta into an agent orchestration framework. By the end, every agent deployed through your framework will have a verifiable identity, and every action will be checked against its scopes and limits before execution.

## What you'll build

A verification layer embedded in your framework's agent runtime. When a developer deploys an agent, the framework registers it with Procta and receives a verifiable credential. At runtime, every agent action passes through a pre-execution hook that calls Procta's `/verify` endpoint.

**Architecture overview:**

```
Developer deploys agent → Framework registers with Procta → Credential issued
                                                                  ↓
Agent executes action → Pre-execution hook → Procta /verify → ALLOWED → Execute
                                                             → DENIED  → Block + Log
```

## Prerequisites

- A Procta **owner** account (for registering agents) and a **relying party** account (for verifying actions)
- Node.js 18+ or Python 3.10+
- An existing agent framework or runtime

## Set up Procta accounts

You need two roles:

- **Owner** — Your framework acts as the agent owner, registering agents on behalf of developers
- **Relying party** — Your framework also verifies agent actions at runtime

<CodeGroup title="Register as owner and relying party">

```bash
# Register as an owner
curl -X POST https://api.procta.org/v1/owners \
  -H "Content-Type: application/json" \
  -d '{
    "name": "AgentFrameworkCo",
    "contactEmail": "platform@agentframework.dev",
    "password": "your-secure-password"
  }'

# Register as a relying party
curl -X POST https://api.procta.org/v1/relying-parties \
  -H "Content-Type: application/json" \
  -d '{
    "name": "AgentFrameworkCo",
    "contactEmail": "platform@agentframework.dev",
    "password": "your-secure-password"
  }'
```

</CodeGroup>

Store both keys:

```bash
export PROCTA_OWNER_KEY="prc_own_abc123..."
export PROCTA_RP_KEY="prc_rp_xyz789..."
```

## Register agents at deploy time

When a developer deploys an agent through your framework, register it with Procta to issue a verifiable credential.

<CodeGroup title="Agent registration on deploy">

```ts
// src/deploy/register-agent.ts

interface AgentRegistration {
  name: string
  description: string
  scopes: string[]
  limits: {
    perTransaction: string
    daily: string
  }
  environment: 'SANDBOX' | 'PRODUCTION'
}

interface ProctaAgent {
  kyaId: string
  credential: string // W3C Verifiable Credential JWT
  status: string
}

export async function registerAgentWithProcta(
  ownerId: string,
  agent: AgentRegistration
): Promise<ProctaAgent> {
  const response = await fetch(
    `https://api.procta.org/v1/owners/${ownerId}/agents`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_OWNER_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        name: agent.name,
        description: agent.description,
        scopes: agent.scopes,
        limits: agent.limits,
        environment: agent.environment,
      }),
    }
  )

  const result = await response.json()

  // Store the credential with the agent's runtime config
  return {
    kyaId: result.agent.kyaId,
    credential: result.credential.vcJwt,
    status: result.agent.status,
  }
}

// Usage in your framework's deploy pipeline
export async function deployAgent(config: AgentConfig) {
  // 1. Build and package the agent
  const artifact = await buildAgent(config)

  // 2. Register with Procta
  const proctaAgent = await registerAgentWithProcta(
    process.env.PROCTA_OWNER_ID!,
    {
      name: config.name,
      description: config.description,
      scopes: config.requestedScopes,
      limits: config.limits,
      environment: config.env === 'prod' ? 'PRODUCTION' : 'SANDBOX',
    }
  )

  // 3. Inject identity into agent runtime
  const runtime = await startAgentRuntime(artifact, {
    kyaId: proctaAgent.kyaId,
    credential: proctaAgent.credential,
  })

  console.log(`Agent deployed: ${proctaAgent.kyaId}`)
  return runtime
}
```

```python
# deploy/register_agent.py
import os
import requests

PROCTA_API_URL = "https://api.procta.org/v1"
PROCTA_OWNER_KEY = os.environ["PROCTA_OWNER_KEY"]


def register_agent_with_procta(owner_id: str, agent: dict) -> dict:
    resp = requests.post(
        f"{PROCTA_API_URL}/owners/{owner_id}/agents",
        headers={"Authorization": f"Bearer {PROCTA_OWNER_KEY}"},
        json={
            "name": agent["name"],
            "description": agent["description"],
            "scopes": agent["scopes"],
            "limits": agent["limits"],
            "environment": agent["environment"],
        },
        timeout=10,
    )
    result = resp.json()

    return {
        "kya_id": result["agent"]["kyaId"],
        "credential": result["credential"]["vcJwt"],
        "status": result["agent"]["status"],
    }


def deploy_agent(config: dict) -> dict:
    # 1. Build and package
    artifact = build_agent(config)

    # 2. Register with Procta
    procta_agent = register_agent_with_procta(
        os.environ["PROCTA_OWNER_ID"],
        {
            "name": config["name"],
            "description": config["description"],
            "scopes": config["requested_scopes"],
            "limits": config["limits"],
            "environment": "PRODUCTION" if config["env"] == "prod" else "SANDBOX",
        },
    )

    # 3. Inject identity into runtime
    runtime = start_agent_runtime(artifact, procta_agent)

    print(f"Agent deployed: {procta_agent['kya_id']}")
    return runtime
```

</CodeGroup>

## Build the pre-execution verification hook

Create a hook that runs before every agent action. This is the core of the integration — it ensures no agent can act without authorization.

<CodeGroup title="Pre-execution hook">

```ts
// src/runtime/verify-hook.ts

interface ActionContext {
  kyaId: string
  action: string
  amount?: string
  asset?: string
  metadata?: Record<string, unknown>
}

interface VerificationResult {
  allowed: boolean
  reason?: string
}

export async function preExecutionHook(
  ctx: ActionContext
): Promise<VerificationResult> {
  try {
    const response = await fetch('https://api.procta.org/v1/verify', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.PROCTA_RP_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        kya_id: ctx.kyaId,
        action: ctx.action,
        amount: ctx.amount,
        asset: ctx.asset,
      }),
    })

    const result = await response.json()

    return {
      allowed: result.decision === 'ALLOWED',
      reason: result.reason,
    }
  } catch (err) {
    // Fail closed — block action if verification is unavailable
    return {
      allowed: false,
      reason: `Verification unavailable: ${err}`,
    }
  }
}

// Integrate into your agent runtime loop
export class VerifiedAgentRuntime {
  private kyaId: string

  constructor(kyaId: string) {
    this.kyaId = kyaId
  }

  async execute(action: string, params: Record<string, unknown>) {
    // Verify before every action
    const verification = await preExecutionHook({
      kyaId: this.kyaId,
      action,
      amount: params.amount as string,
      asset: params.asset as string,
    })

    if (!verification.allowed) {
      throw new Error(`Action blocked: ${verification.reason}`)
    }

    // Action is authorized — execute it
    return this.runAction(action, params)
  }

  private async runAction(action: string, params: Record<string, unknown>) {
    // Your framework's action execution logic
  }
}
```

```python
# runtime/verify_hook.py
import os
import requests

PROCTA_API_URL = "https://api.procta.org/v1/verify"
PROCTA_RP_KEY = os.environ["PROCTA_RP_KEY"]


def pre_execution_hook(kya_id: str, action: str, amount: str = None, asset: str = None) -> dict:
    try:
        resp = requests.post(
            PROCTA_API_URL,
            headers={"Authorization": f"Bearer {PROCTA_RP_KEY}"},
            json={
                "kya_id": kya_id,
                "action": action,
                "amount": amount,
                "asset": asset,
            },
            timeout=5,
        )
        result = resp.json()
        return {
            "allowed": result["decision"] == "ALLOWED",
            "reason": result.get("reason"),
        }
    except requests.RequestException as e:
        return {"allowed": False, "reason": f"Verification unavailable: {e}"}


class VerifiedAgentRuntime:
    def __init__(self, kya_id: str):
        self.kya_id = kya_id

    def execute(self, action: str, **params):
        verification = pre_execution_hook(
            self.kya_id,
            action,
            amount=params.get("amount"),
            asset=params.get("asset"),
        )

        if not verification["allowed"]:
            raise PermissionError(f"Action blocked: {verification['reason']}")

        return self._run_action(action, params)

    def _run_action(self, action: str, params: dict):
        # Your framework's action execution logic
        pass
```

</CodeGroup>

## Handle multi-agent coordination

In multi-agent systems, each agent in a swarm needs its own identity. Register each agent individually and verify actions independently.

<CodeGroup title="Multi-agent swarm setup">

```ts
// src/runtime/swarm.ts

interface SwarmConfig {
  name: string
  agents: Array<{
    role: string
    scopes: string[]
    limits: { perTransaction: string; daily: string }
  }>
}

export async function deploySwarm(config: SwarmConfig) {
  const runtimes: VerifiedAgentRuntime[] = []

  for (const agentConfig of config.agents) {
    const proctaAgent = await registerAgentWithProcta(
      process.env.PROCTA_OWNER_ID!,
      {
        name: `${config.name}-${agentConfig.role}`,
        description: `${agentConfig.role} agent in ${config.name} swarm`,
        scopes: agentConfig.scopes,
        limits: agentConfig.limits,
        environment: 'PRODUCTION',
      }
    )

    const runtime = new VerifiedAgentRuntime(proctaAgent.kyaId)
    runtimes.push(runtime)
  }

  return runtimes
}

// Example: Deploy a DeFi swarm with scoped agents
const swarm = await deploySwarm({
  name: 'defi-optimizer',
  agents: [
    {
      role: 'scanner',
      scopes: ['defi:read'],
      limits: { perTransaction: '0', daily: '0' },
    },
    {
      role: 'executor',
      scopes: ['defi:deposit', 'defi:withdraw'],
      limits: { perTransaction: '10000', daily: '50000' },
    },
    {
      role: 'reporter',
      scopes: ['audit:read'],
      limits: { perTransaction: '0', daily: '0' },
    },
  ],
})
```

```python
# runtime/swarm.py

async def deploy_swarm(config: dict) -> list:
    runtimes = []

    for agent_config in config["agents"]:
        procta_agent = register_agent_with_procta(
            os.environ["PROCTA_OWNER_ID"],
            {
                "name": f"{config['name']}-{agent_config['role']}",
                "description": f"{agent_config['role']} agent in {config['name']} swarm",
                "scopes": agent_config["scopes"],
                "limits": agent_config["limits"],
                "environment": "PRODUCTION",
            },
        )

        runtime = VerifiedAgentRuntime(procta_agent["kya_id"])
        runtimes.append(runtime)

    return runtimes


# Example: Deploy a DeFi swarm with scoped agents
swarm = deploy_swarm({
    "name": "defi-optimizer",
    "agents": [
        {
            "role": "scanner",
            "scopes": ["defi:read"],
            "limits": {"perTransaction": "0", "daily": "0"},
        },
        {
            "role": "executor",
            "scopes": ["defi:deposit", "defi:withdraw"],
            "limits": {"perTransaction": "10000", "daily": "50000"},
        },
        {
            "role": "reporter",
            "scopes": ["audit:read"],
            "limits": {"perTransaction": "0", "daily": "0"},
        },
    ],
})
```

</CodeGroup>

<Note type="info" title="Least-privilege principle">
Give each agent in a swarm only the scopes it needs. A scanner agent should never have `defi:withdraw` — even if it's in the same swarm as the executor.
</Note>

## Test the full flow

```bash
# Deploy an agent through your framework
curl -X POST http://localhost:4000/deploy \
  -H "Content-Type: application/json" \
  -d '{
    "name": "yield-optimizer",
    "scopes": ["defi:deposit", "defi:withdraw"],
    "limits": { "perTransaction": "10000", "daily": "50000" },
    "env": "prod"
  }'

# The agent tries to execute an action
# (this happens internally through the pre-execution hook)

# Check the audit trail
curl https://api.procta.org/v1/audit/logs \
  -H "Authorization: Bearer ${PROCTA_RP_KEY}" \
  -G -d "agentId=kya_01kagent9x3mfq72a0"
```

**Expected behavior:**

| Scenario | Result |
|---|---|
| Agent action within scope and limits | Executes normally |
| Agent action outside scope | Blocked with `SCOPE_NOT_AUTHORIZED` |
| Agent action exceeds limits | Blocked with `LIMIT_EXCEEDED` |
| Agent revoked by owner | Blocked with `AGENT_REVOKED` |

## What's next

- **[Agent Frameworks use case](/use-cases/agent-frameworks)** — Conceptual overview of framework-level integration
- **[Owner Guide](/guides/owner-guide)** — Managing agents, rotating keys, and updating scopes
- **[Credentials](/credentials)** — How Procta's W3C Verifiable Credentials work
- **[Key Rotation](/guides/key-rotation)** — Rotate agent credentials without downtime
